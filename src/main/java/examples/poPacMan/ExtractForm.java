/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package examples.poPacMan;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.EnumMap;
import java.util.Random;
import pacman.game.Constants;
import pacman.game.Constants.GHOST;
import pacman.game.Constants.MOVE;
import pacman.game.Game;

/**
 *
 * @author Giang
 */
public class ExtractForm extends javax.swing.JFrame {

    /**
     * Creates new form extractForm
     */
    public int pacmanX, pacmanY;
    int ghostPosition[][];
    int pillPosition[][];
    int pillActivePosition[][];

    final int unit = 4;
    final int unitX = 8;
    int margin = 25;

    public MCTSNode MCTSTree;
    int twoNearestChild[];
    Game game;

    public ExtractForm() {
        initComponents();
        ghostPosition = new int[4][2];
        pillPosition = new int[300][2];
        pillActivePosition = new int[300][2];
        twoNearestChild = new int[4];
        MCTSTree = new MCTSNode();

    }

    public ExtractForm(Game game) {
        initComponents();
        ghostPosition = new int[4][2];
        pillPosition = new int[300][2];
        pillActivePosition = new int[300][2];
        twoNearestChild = new int[4];
        updateGameInformation(game);

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnRandomPosition = new javax.swing.JButton();
        btnRunMCTS = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Extract Infomation");
        setBackground(new java.awt.Color(51, 51, 51));

        btnRandomPosition.setText("Random");
        btnRandomPosition.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnRandomPositionActionPerformed(evt);
            }
        });

        btnRunMCTS.setText("RunMCTS");
        btnRunMCTS.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnRunMCTSActionPerformed(evt);
            }
        });

        jButton1.setText("Move");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(243, Short.MAX_VALUE)
                .addComponent(btnRandomPosition)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnRunMCTS)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButton1)
                .addGap(23, 23, 23))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(562, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnRandomPosition)
                    .addComponent(btnRunMCTS)
                    .addComponent(jButton1))
                .addContainerGap())
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents
int numOfRunMCTS = 0;
    private void btnRandomPositionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnRandomPositionActionPerformed
        // TODO add your handling code here:
        randomPosition();
        this.repaint();
        this.validate();
        numOfRunMCTS = 0;

    }//GEN-LAST:event_btnRandomPositionActionPerformed

    private void btnRunMCTSActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnRunMCTSActionPerformed
        // TODO add your handling code here:
        this.MCTSTree.setGame(game);
        //System.out.println("\n# th" + numOfRunMCTS + " MCTS current pill " + MCTSTree.game.getActivePillsIndices().length);
        this.MCTSTree.runMCTS(MCTSTree, MCTSTree.game.getActivePillsIndices().length);
        this.MCTSTree.print(this.MCTSTree);
        numOfRunMCTS++;
    }//GEN-LAST:event_btnRunMCTSActionPerformed
    MOVE bestMove;
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        /*
        for (int i = 0; i < 50; i++) {
            btnRunMCTSActionPerformed(null);
        }
        */
        bestMove = MCTSTree.selectBestMove(game,true);
        System.out.println("\nRETURN MOVE" + bestMove + " reach to " + MCTSTree.listChild[MCTSTree.selectedChild].nodeIndex);
       this.MCTSTree.print(this.MCTSTree);
          EnumMap<GHOST, MOVE> listGhostMove = new EnumMap<GHOST, MOVE>(GHOST.class);

            // get Ghost current Move
            for (GHOST ghost : GHOST.values()) {
                 Random R = new Random();
                int len =  game.getPossibleMoves(game.getGhostCurrentNodeIndex(ghost)).length;
                
                if (len==0) break;
                else {
                    MOVE[] moves =game.getPossibleMoves(game.getGhostCurrentNodeIndex(ghost));
                // If it is > 0 then it is visible so no more PO checks
                listGhostMove.put(ghost,moves[R.nextInt(moves.length)]);
                }
            }
        
        game.advanceGame(bestMove,listGhostMove);
        
        btnRandomPositionActionPerformed(null);
    }//GEN-LAST:event_jButton1ActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnRandomPosition;
    private javax.swing.JButton btnRunMCTS;
    private javax.swing.JButton jButton1;
    // End of variables declaration//GEN-END:variables

    public void updateGameInformation(Game game) {
        this.game = game.copy();
        // pacman
        int currentPosition = game.getPacmanCurrentNodeIndex();
        pacmanX = game.getNodeXCood(currentPosition);
        pacmanY = game.getNodeYCood(currentPosition);
        int index = 0;
        // ghost
        // Strategy 1: Adjusted for PO
        for (GHOST ghost : GHOST.values()) {

            // If can't see these will be -1 so all fine there
            int ghostLocation = game.getGhostCurrentNodeIndex(ghost);
            if (ghostLocation != -1) {
                ghostPosition[index][0] = game.getNodeXCood(ghostLocation);
                ghostPosition[index][1] = game.getNodeYCood(ghostLocation);
            } else {
                ghostPosition[index][0] = -1;
                ghostPosition[index][1] = -1;
            }
            index++;
        }

        // PILLs
        int[] pillIndices = game.getPillIndices();

        int count = 0, countActive = 0;
        int tempActiveArray[][] = new int[300][2];
        int tempArray[][] = new int[300][2];

        for (int pillIndex : pillIndices) {
            tempArray[count][0] = game.getNodeXCood(pillIndex);
            tempArray[count][1] = game.getNodeYCood(pillIndex);
            count++;
        }

        pillIndices = game.getActivePillsIndices();

        for (int pillIndex : pillIndices) {
            if (game.isPillStillAvailable(game.getPillIndex(pillIndex))) {
                tempActiveArray[countActive][0] = game.getNodeXCood(pillIndex);
                tempActiveArray[countActive][1] = game.getNodeYCood(pillIndex);
                countActive++;
            }
        }

        this.pillActivePosition = new int[countActive][2];
        this.pillActivePosition = tempActiveArray;
        this.pillPosition = new int[count][2];
        this.pillPosition = tempArray;

    }

    public void paint(Graphics g) {
        g.setColor(Color.black);

        g.fillRect(margin, margin, 113 * 4, 130 * 4);

        // ghost Position
        g.setColor(Color.green);
        for (int i = 0; i < 4; i++) {
            g.fillRect(ghostPosition[i][0] * unit + margin, ghostPosition[i][1] * unit + margin, unitX, unitX);
        }

        // ACTIVE PILLS Position
        g.setColor(Color.YELLOW);
        int lenActive = this.pillActivePosition.length;
        for (int i = 0; i < lenActive; i++) {
            g.fillRect(pillActivePosition[i][0] * unit + margin + unitX / 4, pillActivePosition[i][1] * unit + margin + unitX / 4, unitX / 2, unitX / 2);
        }

        // drawJuction
        g.setColor(Color.white);
        int lenConjunction = this.game.getJunctionIndices().length;
        int listJuction[] = new int[lenConjunction + 1];
        listJuction = this.game.getJunctionIndices();
        for (int i = 0; i < lenConjunction; i++) {
              g.setColor(Color.WHITE);
        g.drawString(listJuction[i] + "", game.getNodeXCood(listJuction[i])  * unit + margin, game.getNodeYCood(listJuction[i]) * unit + margin - 10);
       
            g.fillRect(game.getNodeXCood(listJuction[i]) * unit + margin - 2, game.getNodeYCood(listJuction[i]) * unit + margin - 2, unitX + 4, unitX + 4);
        }

        // draw MCTS Tree;
        g.setFont(new Font(Font.SERIF, Font.PLAIN, 10));

        if (MCTSTree != null) {
            g.setColor(Color.ORANGE);
             g.fillRect(game.getNodeXCood(MCTSTree.nodeIndex) * unit + margin - 2, game.getNodeYCood(MCTSTree.nodeIndex) * unit + margin - 2, unitX + 4, unitX + 4);
    
            drawTree(g, MCTSTree);
        }

        g.setColor(Color.blue);
        // pacman Position
        g.fillRect(pacmanX * unit + margin, pacmanY * unit + margin, unitX, unitX);

        //   repaint();
        // validate();
    }

    void drawTree(Graphics g, MCTSNode root) {
        if (root == null) {
            return;
        }

        paint(g, root.game.getNodeXCood(root.nodeIndex), root.game.getNodeYCood(root.nodeIndex), root.nodeIndex);

        if (root.isLeaf()) {
            return;
        }

        for (MCTSNode child : root.listChild) {
            if (child == null) {
                continue;
            }
            drawTree(g, child);
            g.setColor(Color.red);
            g.drawLine(root.game.getNodeXCood(child.nodeIndex) * unit + margin + unit / 2, root.game.getNodeYCood(child.nodeIndex) * unit + margin + unit / 2,
                    root.game.getNodeXCood(root.nodeIndex) * unit + margin + unit / 2, root.game.getNodeYCood(root.nodeIndex) * unit + margin + unit / 2);

        }

    }

// draw specific point
    public void paint(Graphics g, int x, int y, int id) {
        g.setColor(Color.WHITE);
        g.drawString(id + "", x * unit + margin, y * unit + margin - 10);
        g.setColor(Color.DARK_GRAY);
        g.fillRect(x * unit + margin, y * unit + margin, unitX, unitX);

    }

    public void randomPosition() {
        MCTSNode root = new MCTSNode();
        root.setGame(game);
        root.parentNode = root;
        root.init( );
        System.out.println("CREATE TREE");
        
        int listJunction []= game.getJunctionIndices();
        Random R = new Random();
      //  root.nodeIndex = listJunction[R.nextInt(listJunction.length)];
       root.nodeIndex = 1110;
        root.createEntireTree(root, 0);
        System.out.println("DONE CREATE\nPRINT TREE");

        root.print(root);

        this.MCTSTree = root;
        this.updateGameInformation(game);

    }
    
     public void autoUpdate() {
         jButton1ActionPerformed(null);

    }

}
